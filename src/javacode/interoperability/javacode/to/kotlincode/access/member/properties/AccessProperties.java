package javacode.interoperability.javacode.to.kotlincode.access.member.properties;

public class AccessProperties {
    public static void main(String[] args) {
        Car car = new Car("Black", "Honda", 2001);
        System.out.println(car.getColor()); // this getter method is generated
        // automatically by kotlin compiler for the fields in Car class with the
        // field Name described in kotlin class - CASE-1

        // Having custom setter in Kotlin class - CASE-2
        Truck truck = new Truck("Grey", "AshokLeyland", 2018, 5);
        //the field name in Truck is created as truckColor and truckCapacity
        // compiler generates automatic getters and setters with the field name,  here the
        // getter is generated as getTruckColor(). Setters are created only for
        // 'var' variables, if we define our own custom setters. then setter calling from java
        // is directed to our custom setter.
        System.out.println(truck.getTruckColor()); // CASE-5 properties name more than
        // words, defined in camel case is preserved while compiler generates getter & setters
        System.out.println(truck.getTruckCapacity());
        truck.setTruckColor("Red"); // will initiate call to custom setter - CASE-3
        // truck.setTruckCapacity(50); // CASE-4 custom setter is made private, cant
                                                           // be accessed from outside
        System.out.println("After changing property values");
        System.out.println(truck.getTruckColor());      // compiler generated getter
        System.out.println(truck.getTruckCapacity());

        // CASE-6
        // if java wants to access te kotlin class property/fields directly without
        // using getter / setter we can set the property/field with annotation '@JvmField'
        System.out.println(truck.model); // model field is accessed directly, not through
                                                                // getter generated by compiler

        // CASE-7 - @JvmField cant be applied to property that's overridden,
                    // @JvmField cant be applied to property that can be overridden,
        Truck heavy = new HeavyTruck();
        System.out.println("Heavy Truck : " + heavy.model);
        System.out.println("Heavy Truck Engine No: " + heavy.getEngineNo());
        // truck is super class of HeavyTruck, we have property in truck as 'EngineNo'
        // @Jvmfield cant be applied to "EngineNo" field in truck and cant be applied
        // HeavyTruck class.
        // to make "EngineNo" field overridden in HeavyTruck it has to be made open
        // in Truck class. @JvmFiled cant be applied to property which has "override" / "open"
        // hence "EngineNo" field cant be applied with @JvmField in Truck Class because it
        // contains 'open' and cant be applied in HeavyTruck as it has 'override' keyword.

        //Conclusion:
        // restrictions of usage of @JvmField
        // 1. cant use it with private properties
        // 2. cant use it with const properties (final / const keyword)
        // 3. cant use it on a property that overrides another property (in subclass)
        // 4. cant use it on a property that is overridden (in super class)
    }
}
